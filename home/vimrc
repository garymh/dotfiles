" ~/.vimrc
" thanks to the brilliant @tpope, @skwp, @nelstrom, @bling,
" @r00k, @AndrewRadev, and @sjl for unknowingly
" allowing me to borrow from their dotfiles.

filetype off
if !1 | finish | endif

if has('vim_starting')
  set nocompatible               " Be iMproved
  set runtimepath+=~/.vim/bundle/neobundle.vim/
endif
call neobundle#begin(expand('~/.vim/bundle/'))
NeoBundleFetch 'Shougo/neobundle.vim'
call neobundle#end()

" Colors, themes, airline {{{ "
NeoBundle 'bling/vim-airline'
NeoBundle 'jonathanfilip/vim-lucius'
NeoBundle 'altercation/vim-colors-solarized.git'
NeoBundle 'whatyouhide/vim-gotham'
NeoBundle 'junegunn/vim-emoji'
NeoBundle 'airblade/vim-gitgutter'

set t_Co=256
set term=xterm-256color
set t_ut=

silent! if emoji#available()
  let g:gitgutter_sign_added            = emoji#for('small_blue_diamond')
  let g:gitgutter_sign_modified         = emoji#for('small_orange_diamond')
  let g:gitgutter_sign_removed          = emoji#for('small_red_triangle')
  let g:gitgutter_sign_modified_removed = emoji#for('collision')
endif
let g:gitgutter_realtime = 0
let g:gitgutter_eager    = 0

set cc=81
syntax enable
colorscheme gotham
let g:airline#extensions#tabline#enabled       = 1
let g:airline#extensions#tabline#tab_min_count = 0
let g:airline_theme='gotham'
" }}} Colors, themes, airline "

" General Settings {{{ "
set completeopt=menu,menuone,longest,preview
" I like menus, longest completions, and previews

set autoread            " reload files changed outside vim
set autowrite           " having an undofile makes this safe, I hope
set cpoptions+=J
set cursorline          " highlight the current line
set dictionary=/usr/share/dict/words
set encoding=utf-8
set expandtab           " auto insert tabs when needed
set gcr=a:blinkon0      " STOP BLINKING
set gdefault            " assume the /g flag on :s substitutions
set hidden              " make unsaved buffers hidden
set hlsearch            " highlight searched phrases
set ignorecase          " ignore case sensitivity on searches
set laststatus=2        " always have a statusbar
set lazyredraw          " make macros faster
set nojoinspaces        " use only 1 space after '.' when joining lines
set number              " show line numbers
set shiftround          " indenting to nearest tabstop
set shortmess=WatAIT    " no interruptive prompts http://items.sjbach.com/319/configuring-vim-right
set showbreak=↪\        " show this character for breaks
set showmatch           " show matching brackets
set showmode            " show the mode
set smartcase           " smartcase for searching
set title               " change the terminal's title
set showbreak=↪\        " show this character for breaks
set splitbelow          " default split behavior
set splitright          " default split behavior
set ttyfast             " fast terminal
set vb                  " quit yer beepin'!
set virtualedit=onemore " allow selection past last character

if v:version > 703
  set formatoptions+=j  " delete comment char when joining commented lines
endif

set backupskip=/tmp/*,/private/tmp/*               " fix vim's crontab problem
set softtabstop=2 tabstop=2 shiftwidth=2 expandtab " sensible tab settings.
set listchars=tab:▸\ ,eol:¬,extends:❯,precedes:❮   " highlight tabs/whitespace
" }}} General Settings "

" Backups {{{ "
set undodir=~/.vim/tmp/undo//     " undo files
set backupdir=~/.vim/tmp/backups// " backups
set directory=~/.vim/tmp/swap//   " swap files
set backup                        " enable backups
set noswapfile

if $VIM_CRONTAB == "true"
  set nobackup
  set nowritebackup
endif

if has('persistent_undo')
  silent !mkdir ~/.vim/backups > /dev/null 2>&1
  set undodir=~/.vim/backups
  set undofile
endif
" }}} Backups "

" Folding {{{ "
set foldlevelstart=99
nnoremap zr zr:echo &foldlevel<cr>
nnoremap zm zm:echo &foldlevel<cr>
nnoremap zR zR:echo &foldlevel<cr>
nnoremap zM zM:echo &foldlevel<cr>
nnoremap <space><space> za
" }}} Folding "

" AutoCommands {{{ "
augroup random
  autocmd!
  autocmd FileType * setlocal formatoptions-=c formatoptions-=r formatoptions-=o formatoptions+=j

  " Help mode bindings
  " <enter> to follow tag, <bs> to go back, and q to quit.
  " From http://ctoomey.com/posts/an-incremental-approach-to-vim/
  autocmd filetype help nnoremap <buffer><cr> <c-]>
  autocmd filetype help nnoremap <buffer><bs> <c-T>
  autocmd filetype help nnoremap <buffer>q :q<CR>

  autocmd BufNewFile,BufRead *pryrc set filetype=ruby
  autocmd BufNewFile,BufRead *pryrc-helpers.rb set filetype=ruby

  " jump the top in git commit messages
  autocmd FileType cf set commentstring=<!--%s-->
  autocmd FileType gitcommit normal gg
  autocmd BufReadPost fugitive://* set bufhidden=delete
augroup END

augroup configureFolds
  autocmd!
  autocmd FileType mkd      setlocal spell nofoldenable
  autocmd FileType markdown setlocal spell nofoldenable
  autocmd FileType text     setlocal spell nofoldenable
  autocmd FileType vim      setlocal foldmethod=marker
augroup END
" }}} AutoCommands "

" Wildmenu completion {{{ "
set wildmenu
set wildmode=list:longest

set wildignore+=.git,.svn                        " Version control
set wildignore+=*.jpg,*.bmp,*.gif,*.png,*.jpeg   " binary images
set wildignore+=*.spl                            " compiled spelling word lists
set wildignore+=*.sw?                            " Vim swap files
set wildignore+=*.DS_Store                       " OSX crap
set wildignore+=vendor/rails/**                  " ruby
set wildignore+=vendor/cache/**
set wildignore+=*.gem
set wildignore+=log/**
set wildignore+=tmp/**

set complete=.,w,b,u,U
" }}} Wildmenu completion "

" Shortcuts and remaps {{{ "

" still not sure about these
imap jj <Esc>
" imap jk <Esc>
inoremap LL <Esc>g~iwea
inoremap LO <Esc>m`b~Ea
inoremap jk ()<Left>
inoremap jk<CR>  (<CR>)<Esc>O
inoremap kj <Esc>/[)}"'\]>]<CR>a

" close window
map <C-x> <C-w>c

" i never use H or L's defaults, might as well make them useful!
noremap H ^
noremap L $
vnoremap L g_

let mapleader=","
let maplocalleader = "\\"

" i use c-a for tmux, so i need to do this remap
nnoremap <c-b> <c-a>

" fix movement
nnoremap j gj
nnoremap k gk

" fix redo in insert mode
inoremap <c-u> <c-g>u<c-u>
inoremap <c-w> <c-g>u<c-w>

" sort lines
nnoremap <leader>s vip:!sort<cr>
vnoremap <leader>s :!sort<cr>

" vimrc sourcing
nnoremap <leader>sv :source $MYVIMRC<cr>
nnoremap <leader>ev :vsplit $MYVIMRC<cr>

" who on earth can reach C-^?
nnoremap <leader><leader> <C-^>

" fugitive/git
nnoremap <silent> <leader>gac :Gcommit -m -a ""<LEFT>
nnoremap <silent> <leader>gc :Gcommit -m ""<LEFT>
nnoremap <silent> <leader>gp :Git push<CR>
nnoremap <silent> <leader>gs :Gstatus<CR><C-w>20+

" below stolen from YADR (@skwp)
" <leader># Surround a word with #{ruby interpolation}
map <leader># ysiw#
vmap <leader># S#

" <leader>" Surround a word with "quotes"
map <leader>" ysiw"
vmap <leader>" S"

" <leader>' Surround a word with 'single quotes'
map <leader>' ysiw'
vmap <leader>' c'<C-R>"'<ESC>

" <leader>) or <leader>( Surround a word with (parens)
" The difference is in whether a space is put in
map <leader>( ysiw(
map <leader>) ysiw)
vmap <leader>( c( <C-R>" )<ESC>
vmap <leader>) c(<C-R>")<ESC>

" <leader>[ Surround a word with [brackets]
map <leader>] ysiw]
map <leader>[ ysiw[
vmap <leader>[ c[ <C-R>" ]<ESC>
vmap <leader>] c[<C-R>"]<ESC>

" <leader>{ Surround a word with {braces}
map <leader>} ysiw}
map <leader>{ ysiw{
vmap <leader>} c{ <C-R>" }<ESC>
vmap <leader>{ c{<C-R>"}<ESC>

" <leader>- and <leader>= for ERB
map <leader>e- ysil-
map <leader>e= ysil=
vmap <leader>e- S-
vmap <leader>e= S=

" <leader>ow = 'overwrite word'<leader> replace a word with what's in the yank buffer
" FIXME: will not properly repeat when you use a dot (tie into repeat.vim)
nnoremap <leader>ow "_diwhp

" via: http://whynotwiki.com/Vim
" Ruby
" Use v or # to get a variable interpolation (inside of a string)}
" ysiw#   Wrap the token under the cursor in #{}
" v...s#  Wrap the selection in #{}
let g:surround_113 = "#{\r}"   " v
let g:surround_35  = "#{\r}"   " #

" Select text in an ERb file with visual mode and then press s- or s=
" Or yss- to do entire line.
let g:surround_45 = "<% \r %>"    " -
let g:surround_61 = "<%= \r %>"   " =

" alias yw to yank the entire word 'yank inner word'
" even if the cursor is halfway inside the word
" FIXME: will not properly repeat when you use a dot (tie into repeat.vim)
nnoremap <leader>yw yiww
nnoremap <leader>yW yiWW

" <leader>hp = html preview
map <silent> <leader>hp :!open -a Safari %<CR><CR>

" TODO: sort me!
nnoremap // :nohlsearch<CR>
nnoremap <leader>. :Scratch<CR>
nnoremap <leader>1 yypVr=
nnoremap <leader>2 yypVr-
nnoremap <leader>= <C-w>=
nmap <leader>fq cs"'
nnoremap <leader>w :w<CR>
vnoremap <leader>h :!tidy -q -i --show-errors 0<CR>

" copy current filename into system clipboard - mnemonic: (c)urrent(f)ilename
" this is helpful to paste someone the path you're looking at
nnoremap <silent> <leader>cf :let @* = expand("%:~")<CR>
nnoremap <silent> <leader>cn :let @* = expand("%:t")<CR>

" " create <%= foo %> erb tags using Ctrl-k in edit mode
" imap <silent> <C-y> <%=   %><Esc>3hi

" " create <%= foo %> erb tags using Ctrl-j in edit mode
" imap <silent> <C-e> <%  %><Esc>2hi

" better copy and paste
vnoremap <leader>y "+y
nnoremap <leader>y "+y
nnoremap <leader>p :set paste<CR>o<esc>"*]p:set nopaste<cr>
nnoremap <leader>P :set paste<CR>O<esc>"*]P:set nopaste<cr>

" splits
nnoremap <leader><bar> <C-w>v<C-w>l
" nnoremap <leader>- <C-w>s
nnoremap <leader>vsa :vert sba<cr>

" quicker close window
nnoremap <silent>Q :call CloseWindowOrKillBuffer()<cr>
command! -bang Q q<bang>
command! -bang QA qa<bang>
command! -bang Qa qa<bang>

" Focus the current line (stolen from @sjl)
nnoremap <leader>zz mzzMzvzz1<c-e>`z:Pulse<cr>

" auto center after certain commands
nnoremap <silent> n nzz
nnoremap <silent> N Nzz
nnoremap <silent> * *zz
nnoremap <silent> # #zz
nnoremap <silent> g* g*zz
nnoremap <silent> g# g#zz
nnoremap <silent> <C-o> <C-o>zz
nnoremap <silent> <C-i> <C-i>zz

" Copy paragraph
noremap cp yap<S-}>p

" Tmux/vim shared navigation
nnoremap <C-w>h :TmuxNavigateLeft<cr>
nnoremap <C-w>j :TmuxNavigateDown<cr>
nnoremap <C-w>k :TmuxNavigateUp<cr>
nnoremap <C-w>l :TmuxNavigateRight<cr>

" reindent the whole file (until beautify ruby comes about.)
nnoremap <leader>= mqHmwgg=G`wzt`q

" reselect visual block after indent
vnoremap < <gv
vnoremap > >gv

" git blame
vmap <Leader>b :<C-U>!git blame <C-R>=expand("%:p") <CR> \| sed -n <C-R>=line("'<") <CR>,<C-R>=line("'>") <CR>p <CR>

" " keep the cursor in place while joining lines
" nnoremap J mzJ`z

" highlight last inserted text
nnoremap gV `[v`]

" split lines, opposite of J
" nnoremap S i<cr><esc>^mwgk:silent! s/\v +$//<cr>:noh<cr>`w

" }}} Shortcuts and remaps "

" Plugins (with NeoBundle) {{{ "
NeoBundle 'tpope/vim-abolish'
NeoBundle 'tpope/vim-bundler'
NeoBundle 'tpope/vim-commentary'
NeoBundle 'tpope/vim-endwise'
NeoBundle 'tpope/vim-eunuch'
NeoBundle 'tpope/vim-fugitive'
NeoBundle 'tpope/vim-jdaddy'
NeoBundle 'tpope/vim-rails'
NeoBundle 'tpope/vim-rake'
NeoBundle 'tpope/vim-repeat'
NeoBundle 'tpope/vim-sensible'
NeoBundle 'tpope/vim-surround'
NeoBundle 'tpope/vim-unimpaired'

NeoBundle 'Julian/vim-textobj-brace'
NeoBundle 'beloglazov/vim-textobj-quotes'
NeoBundle 'glts/vim-textobj-comment'
NeoBundle 'kana/vim-textobj-entire'
NeoBundle 'kana/vim-textobj-fold'
NeoBundle 'kana/vim-textobj-indent'
NeoBundle 'kana/vim-textobj-line'
NeoBundle 'kana/vim-textobj-user'
NeoBundle 'tek/vim-textobj-ruby'
NeoBundle 'whatyouhide/vim-textobj-erb'
NeoBundle 'beloglazov/vim-textobj-punctuation'

NeoBundle 'justinmk/vim-gtfo'
NeoBundle 'benmills/vimux'
NeoBundle 'ConradIrwin/vim-bracketed-paste'
NeoBundle 'atimholt/spiffy_foldtext'
NeoBundle 'chrisbra/Colorizer'
NeoBundle 'christoomey/vim-tmux-navigator'
NeoBundle 'duff/vim-scratch'
NeoBundle 'honza/vim-snippets'
NeoBundle 'mileszs/ack.vim'
NeoBundle 'sareyko/neat.vim'
NeoBundle 'sjl/gundo.vim'
NeoBundle 'kristijanhusak/vim-multiple-cursors'
NeoBundle 'vim-scripts/SearchComplete'
NeoBundle 'jszakmeister/vim-togglecursor'
NeoBundle 'endel/vim-github-colorscheme'
NeoBundle 'mattn/emmet-vim'

NeoBundle 'esneider/YUNOcommit.vim'
let g:YUNOcommit_after = 20

NeoBundle 'Chiel92/vim-autoformat'
" https://github.com/Chiel92/vim-autoformat
" figure out how to use this!

if has('mac')
  NeoBundle 'zerowidth/vim-copy-as-rtf'
  xnoremap <Leader>C <esc>:colo github<cr>gv:CopyRTF<cr>:colo gotham<cr>
endif

NeoBundle 'Yggdroot/indentLine'
NeoBundle 'slim-template/vim-slim'
NeoBundle 'groenewege/vim-less'
NeoBundle 'kchmck/vim-coffee-script'
NeoBundle 'davejlong/cf-utils.vim'
NeoBundle 'zaiste/tmux.vim'
NeoBundle 'xolox/vim-misc'
NeoBundle 'toyamarinyon/vim-swift'

nnoremap <leader>nbu :Unite neobundle/update -vertical -no-start-insert<cr>

" DelimitMate {{{ "
NeoBundle 'Raimondi/delimitMate'
let delimitMate_expand_cr=1
let delimitMate_expand_space=1
let delimitMate_balance_matchpairs=1
" }}} DelimitMate "

" Investigate.vim {{{ "
NeoBundle 'Keithbsmiley/investigate.vim'
let g:investigate_use_dash=1
nnoremap K :call investigate#Investigate()<CR>
" }}} Investigate.vim "

" Undo Quit {{{ "
NeoBundle 'AndrewRadev/undoquit.vim'
let g:undoquit_mapping = '_u'
" }}} Undo Quit "

" Switch.vim {{{ "
NeoBundle 'AndrewRadev/switch.vim'
nnoremap - :Switch<cr>
nnoremap <silent> <CR> :<C-u>call <SID>try('Switch', "\015")<CR>
" }}} Switch.vim "

" SplitJoin {{{ "
NeoBundle 'AndrewRadev/splitjoin.vim'
nmap cS :SplitjoinSplit<cr><esc>
nmap cJ :SplitjoinJoin<cr><esc>

function! s:normal_split()
  execute 'i<cr><esc>^mwgk:silent! s/\v +$//<cr>:noh<cr>`w'
endfunction

function! s:try(cmd, default)
  if exists(':' . a:cmd) && !v:count
    let tick = b:changedtick
    execute a:cmd
    if tick == b:changedtick
      execute join(['normal!', a:default])
    endif
  else
    execute join(['normal! ', v:count, a:default], '')
  endif
endfunction
" }}} SplitJoin "

" Misc {{{ "
let g:ackprg = 'ag --nogroup --nocolor --column --line-numbers'

vnoremap <Leader>v :MultipleCursorsFind <C-R><C-W><CR>
nnoremap <Leader>v :MultipleCursorsFind <C-R><C-W><CR>
" }}} Misc "

" Ruby {{{ "
NeoBundleLazy 'ngmy/vim-rubocop' , { "autoload" : { "filetypes" : ["ruby"] } }
let g:vimrubocop_rubocop_cmd = "/usr/local/opt/rbenv/shims/rubocop"
NeoBundle 'ecomba/vim-ruby-refactoring'
NeoBundle 'tpope/vim-rbenv'
NeoBundle 'vim-ruby/vim-ruby'
let ruby_fold=1

nnoremap <silent> ,orb :normal varar%<esc><esc>

let g:rails_projections = {
      \ "config/routes.rb": { "command": "routes" }
      \ }

" Ruby Testing {{{ "
NeoBundle 'pgr0ss/vimux-ruby-test'
nnoremap <silent> <leader>t :RunRailsFocusedTest<cr>
nnoremap <silent> <leader>T :RunAllRubyTests<cr>
nnoremap <silent> <leader>l :VimuxRunLastCommand<cr>
nnoremap <silent> <leader>L :call VimuxRunCommand("clear && rake test")<cr>
nnoremap <leader>! :call VimuxRunCommand("")<left><left>

let g:vimux_ruby_cmd_unit_test = "ruby"
let g:vimux_ruby_cmd_all_tests = "ruby -Itest"
let g:vimux_ruby_clear_console_on_run = 1
" }}} Ruby Testing "
" }}} Ruby "

" Inline Edit {{{ "
NeoBundle 'AndrewRadev/inline_edit.vim'
nnoremap <leader>ie :InlineEdit<cr>
xnoremap <leader>ie :InlineEdit<cr>
" }}} Inline Edit "

" Completions {{{ "
" NeoBundle 'Valloric/YouCompleteMe'
NeoBundle 'Shougo/neocomplete'
NeoBundle 'Shougo/neosnippet'
NeoBundle 'Shougo/neosnippet-snippets'
NeoBundle 'supermomonga/neocomplete-rsense.vim'
let g:neocomplete#sources#rsense#home_directory = '/usr/local/bin/rsense'
let g:neocomplete#enable_at_startup = 1

" Called once right before you start selecting multiple cursors
function! Multiple_cursors_before()
  if exists(':NeoCompleteLock')==2
    exe 'NeoCompleteLock'
  endif
endfunction

" Called once only when the multiple selection is canceled
function! Multiple_cursors_after()
  if exists(':NeoCompleteUnlock')==2
    exe 'NeoCompleteUnlock'
  endif
endfunction

" set filetype
autocmd BufNewFile,BufRead *vimrc set filetype=vim

" Enable omni completion.
autocmd FileType eruby,html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS

autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete
if !exists('g:neocomplete#force_omni_input_patterns')
  let g:neocomplete#force_omni_input_patterns = {}
endif
let g:neocomplete#force_omni_input_patterns.ruby =
      \ '[^. *\t]\.\w*\|\h\w*::'

" Plugin key-mappings.
imap <C-;>     <Plug>(neosnippet_expand_or_jump)
smap <C-;>     <Plug>(neosnippet_expand_or_jump)
xmap <C-;>     <Plug>(neosnippet_expand_target)

" SuperTab like snippets behavior.
imap <expr><TAB> neosnippet#expandable_or_jumpable() ?
      \ "\<Plug>(neosnippet_expand_or_jump)"
      \: pumvisible() ? "\<C-n>" : "\<TAB>"
smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
      \ "\<Plug>(neosnippet_expand_or_jump)"
      \: "\<TAB>"

" For snippet_complete marker.
if has('conceal')
  set conceallevel=2 concealcursor=i
endif

" }}} Completions "

" Better Whitespace {{{ "
NeoBundle 'ntpeters/vim-better-whitespace'
let g:strip_whitespace_on_save = 1
let g:better_whitespace_enabled = 0
" }}} Better Whitespace "

" Sideways.vim {{{ "
NeoBundle 'AndrewRadev/sideways.vim'
" NeoBundle 'tek/vim-fieldtrip'
" let g:fieldtrip_start_map = 'ss'
nnoremap s< :SidewaysLeft<cr>
nnoremap s> :SidewaysRight<cr>
" }}} Sideways.vim "

" Unite {{{ "

NeoBundle 'Shougo/unite-session'
NeoBundle 'Shougo/unite.vim'
NeoBundle 'Shougo/neomru.vim'
NeoBundle 'Shougo/vimproc', { 'build': {
      \   'mac': 'make -f make_mac.mak',
      \   'unix': 'make -f make_unix.mak',
      \ } }

nnoremap [unite] <Nop>
nmap <space> [unite]

let g:unite_data_directory                  = '~/.vim/tmp/unite'
let g:unite_enable_short_source_names       = 1
let g:unite_source_session_enable_auto_save = 1
let g:unite_source_history_yank_enable      = 1
let g:unite_split_rule                      = 'botright'
let g:unite_winheight                       = 14

if executable('ag')
  " Use ag in unite grep source.
  let g:unite_source_grep_command = 'ag'
  let g:unite_source_grep_default_opts =
        \ '-i --line-numbers --smart-case --nocolor --nogroup --hidden --ignore ' .
        \  '''.hg'' --ignore ''.svn'' --ignore ''.git'' --ignore ''.bzr'''
  let g:unite_source_grep_recursive_opt = ''
elseif executable('ack')
  let g:unite_source_rec_async_command = 'ack -f --nofilter'
  let g:unite_source_grep_command = 'ack'
  let g:unite_source_grep_default_opts = '--no-color --no-heading'
  let g:unite_source_grep_recursive_opt = ''
endif

" autocmd User Rails nnoremap <Leader>m :Rmodel<Space>
" autocmd User Rails nnoremap <Leader>c :Rcontroller<Space>
" autocmd User Rails nnoremap <Leader>v :Rview<Space>
" autocmd User Rails nnoremap <Leader>u :Runittest<Space>

nnoremap <silent> <C-p> :Unite -toggle -start-insert -buffer-name=files -prompt-direction=top file_rec/async:!<CR>
nnoremap <silent> [unite]p :<C-u>Unite -buffer-name=sessions session<CR>
nnoremap <silent> [unite]c :<C-u>Unite -buffer-name=commands -start-insert command<CR>
nnoremap <silent> [unite]k :<C-u>Unite -quick-match buffer <CR>
nnoremap <silent> [unite]m :<C-u>Unite -auto-resize -buffer-name=mappings mapping<cr>
nnoremap <silent> [unite]y :<C-u>Unite -buffer-name=yanks history/yank<cr>
nnoremap <silent> [unite]rm :<C-u>Unite -input=app/models/ file<CR>
nnoremap <silent> [unite]f :<C-u>Unite -no-start-insert grep:.<cr>
nnoremap <silent> [unite]m :Unite -buffer-name=recent -winheight=10 file_mru<cr>
" nnoremap <silent> [unite]r :call unite#action#do_candidates('rename',unite#get_candidates([['file', expand('%')]])<CR>
nnoremap <silent> [unite]/ :<C-u>Unite -no-quit -buffer-name=search grep:.<cr>
nnoremap <silent> [unite]g :call unite#mappings#_choose_action(unite#get_candidates([['file', expand('%')]]))<CR>

nnoremap <silent> [unite]t :Unite -silent -auto-resize -auto-highlight
      \ -buffer-name=task-list vimgrep:%:\\CTODO\:\\<bar>FIXME\:<CR>
nnoremap <silent> [unite]r :Unite -silent -auto-resize -immediately resume<CR>

let s:unite_ignores = [
      \ '\.git', 'dist',
      \ 'undo', 'backups',
      \ 'generated', 'build', 'images']

call unite#filters#matcher_default#use(['matcher_fuzzy'])
call unite#filters#sorter_default#use('sorter_selecta')

call unite#custom#source('file_rec/async','sorters','sorter_rank')

" call unite#set_profile('files', 'smartcase', 1)
call unite#custom#profile('files', 'context.smartcase', 1)
call unite#custom#source('line,outline','matchers','matcher_fuzzy')

autocmd FileType unite call s:unite_my_settings()
function! s:unite_my_settings()
  imap <buffer> <C-w> <Plug>(unite_delete_backward_path)
  nmap <buffer> <ESC> <Plug>(unite_exit)
  imap <buffer> <TAB> <Plug>(unite_select_next_line)

  " jj kk becuase you're lazy, and leave insert mode
  " NEW! if unite breaks, remove
  imap <buffer> jj <Plug>(unite_insert_leave)
  imap <buffer> kk <Plug>(unite_insert_leave)

  nmap <buffer> Q <plug>(unite_exit)

  let unite = unite#get_current_unite()
  if unite.profile_name ==# 'search'
    nnoremap <silent><buffer><expr> r     unite#do_action('replace')
  else
    nnoremap <silent><buffer><expr> r     unite#do_action('rename')
  endif

endfunction
" }}} Unite "

" Tabularize {{{ "
NeoBundle 'junegunn/vim-easy-align'
vmap <Enter> <Plug>(EasyAlign)
nmap <Leader>aa <Plug>(EasyAlign)ii<CR>
let g:easy_align_delimiters = {
      \ '>': { 'pattern': '>>\|=>\|>' },
      \ '\': { 'pattern': '\\' },
      \ '/': { 'pattern': '//\+\|/\*\|\*/', 'delimiter_align': 'l', 'ignore_groups': ['!Comment'] },
      \ ']': {
      \     'pattern':       '[[\]]',
      \     'left_margin':   0,
      \     'right_margin':  0,
      \     'stick_to_left': 0
      \   },
      \ ')': {
      \     'pattern':       '[()]',
      \     'left_margin':   0,
      \     'right_margin':  0,
      \     'stick_to_left': 0
      \   },
      \ 'f': {
      \     'pattern': ' \(\S\+(\)\@=',
      \     'left_margin': 0,
      \     'right_margin': 0
      \   },
      \ 'd': {
      \     'pattern': ' \(\S\+\s*[;=]\)\@=',
      \     'left_margin': 0,
      \     'right_margin': 0
      \   }
      \ }
" NeoBundle 'godlygeek/tabular'

" For custom Tabularize definitions see after/plugin/tabularize.vim
" taken from @AndrewRadev
" nnoremap <leader>aa      :call <SID>Tabularize(0)<cr>
" xnoremap <leader>aa :<c-u>call <SID>Tabularize(1)<cr>
" function! s:Tabularize(visual)
"   let saved_cursor = getpos('.')

"   echohl ModeMsg | echo "-- ALIGN -- "  | echohl None
"   let char = nr2char(getchar())

"   if     char == '=' | let alignment = 'equals'
"   elseif char == '>' | let alignment = 'ruby_hash'
"   elseif char == ',' | let alignment = 'commas'
"   elseif char == ':' | let alignment = 'colons'
"   elseif char == ' ' | let alignment = 'space'
"   else
"     " just try aligning by the character
"     let char = escape(char, '/.')
"     let alignment = '/'.char
"   endif

"   if a:visual
"     exe "'<,'>Tabularize ".alignment
"   else
"     exe 'Tabularize '.alignment
"   endif

"   echo
"   call setpos('.', saved_cursor)
" endfunction
" }}} Tabularize "

NeoBundleCheck

" }}} Plugins (with NeoBundle) "

" Handy Functions {{{ "
" Pulse - stolen from @sjl
function! s:Pulse() " {{{
  redir => old_hi
  silent execute 'hi CursorLine'
  redir END
  let old_hi = split(old_hi, '\n')[0]
  let old_hi = substitute(old_hi, 'xxx', '', '')

  let steps = 8
  let width = 1
  let start = width
  let end = steps * width
  let color = 233

  for i in range(start, end, width)
    execute "hi CursorLine ctermbg=" . (color + i)
    redraw
    sleep 6m
  endfor
  for i in range(end, start, -1 * width)
    execute "hi CursorLine ctermbg=" . (color + i)
    redraw
    sleep 6m
  endfor

  execute 'hi ' . old_hi
endfunction " }}}
command! -nargs=0 Pulse call s:Pulse()

" from @bling
function! CloseWindowOrKillBuffer() "{{{
  let number_of_windows_to_this_buffer = len(filter(range(1, winnr('$')), "winbufnr(v:val) == bufnr('%')"))

  if number_of_windows_to_this_buffer > 1
    wincmd c
  else
    bdelete
  endif
endfunction

" Change between `method arg1, arg2` and `method(arg1, arg2)`
" from @AndrewRadev
function! s:ToggleBrackets()
  let arguments = sideways#Parse()
  if empty(arguments)
    return
  endif

  let saved_view = winsaveview()

  let line            = getline('.')
  let start_col       = arguments[0][0]
  let start_col_index = start_col - 1
  let end_col         = arguments[-1][1]
  let end_col_index   = end_col - 1

  if line[start_col_index - 1] == '(' && line[end_col_index + 1] == ')'
    exe "normal! ".(start_col - 1)."|r\<space>"
    exe "normal! ".(end_col + 1)."|x"
  elseif line[start_col_index - 1] == ' '
    exe "normal! ".(start_col - 1)."|r("
    exe "normal! ".(end_col)."|a)"
  endif

  call winrestview(saved_view)
endfunction

" Make the given command repeatable using repeat.vim
command! -nargs=* Repeatable call s:Repeatable(<q-args>)
function! s:Repeatable(command)
  exe a:command
  call repeat#set(':Repeatable '.a:command."\<cr>")
endfunction

nnoremap g( :Repeatable call <SID>ToggleBrackets()<cr>
nnoremap g) :Repeatable call <SID>ToggleBrackets()<cr>
" }}} Handy Functions "


" vim: set fdm=marker
