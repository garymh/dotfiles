def show_screen
  if respond_to?(:save_screenshot)
    page.save_screenshot("screenshot.png")
    system("open 'screenshot.png'")
  end
end

# Lots below stolen from Juanito Fatas
# https://github.com/JuanitoFatas/dotpryrc

Pry.config.theme = "tomorrow"
Pry.config.color = true

Pry.config.ls.separator = "\n" # new lines between methods
Pry.config.ls.heading_color = :magenta
Pry.config.ls.public_method_color = :green
Pry.config.ls.protected_method_color = :yellow
Pry.config.ls.private_method_color = :bright_black

require '~/.pryrc-helpers'

# ___ is to Avoid name conflict
___ = PryrcHelpers

___daily_gems  = %w[benchmark yaml json pry-bloodline]
___pry_gems = %w[awesome_print hirb]

___daily_gems.___require_gems
___pry_gems.___require_gems

if defined? Hirb
  Hirb::View.instance_eval do
    def enable_output_method
      @output_method = true
      @old_print = Pry.config.print
      Pry.config.print = proc do |output, value|
        Hirb::View.view_or_page_output(value) || @old_print.call(output, value)
      end
    end

    def disable_output_method
      Pry.config.print = @old_print
      @output_method = nil
    end
  end

  Hirb.enable
end

if defined? AwesomePrint
  AwesomePrint.pry!
  Pry.config.print = proc {|output, value| Pry::Helpers::BaseHelpers.stagger_output("=> #{value.ai(indent: 2)}", output)}

  if defined? Minitest
    module Minitest::Assertions
      def mu_pp(obj)
        obj.awesome_inspect
      end
    end
  end
end

Pry.config.history.file = "~/.irb_history"

if defined?(PryBloodline)
  PryBloodline.setup!
  PryBloodline.configure do |c|
    c.line_color = :red
    c.name_color = :white
    c.path_color = :light_blue
    c.separator = "âš¡"
  end
end

Pry.config.exception_handler = proc do |output, exception, _|
  puts ___.colorize "#{exception.class}: #{exception.message}", 31
  puts ___.colorize "from #{exception.backtrace.first}", 31
end

Pry.config.commands.alias_command 'w', 'whereami'
Pry.config.commands.alias_command 'clear', '.clear'
Pry.commands.alias_command '..', 'cd ..'
Pry.commands.alias_command '...', 'cd ../..'
Pry.commands.alias_command '....', 'cd ../../..'
Pry.commands.alias_command 'ed', 'edit'
Pry.commands.alias_command 'em', 'edit -m'
Pry.commands.alias_command 'ec', 'edit -c'
Pry.commands.alias_command 'la', 'ls -ppp'
Pry.commands.alias_command 'll', 'ls -M'
Pry.commands.alias_command 'rm', 'reload-method'
Pry.commands.alias_command 'ss', 'show-source'
Pry.commands.alias_command 'fm', 'find-method'
Pry.commands.alias_command 'q', '!!!'

alias :r :require
alias :l :load
# alias :ref :reload!
### Copy to clipboard!

# ==============================
#   pbcopy
# ==============================
# Create command 'pbcopy' : Copy the last returned value in the Mac OS clipboard
# options : -m : Multiline copy
# Usage :
#         a => [1, 2, 3]
#         pbcopy
#         [1, 2, 3]
#         pbcopy -m
#          [
#           1,
#           2,
#           3,
#          ]
if RUBY_PLATFORM =~ /darwin/i # OSX only.
  # The pbcopy manual page for Mac OS X
  # http://goo.gl/o3nGsr
  def pbcopy(str, opts = {})
    IO.popen('pbcopy', 'r+') { |io| io.print str }
  end

  Pry.config.commands.command "pbcopy", "Copy last returned object to clipboard, -m for multiline copy" do

    multiline = arg_string == '-m'
    pbcopy _pry_.last_result.ai(:plain => true,
                                :indent => 2,
                                :index => false,
                                :multiline => multiline)
    output.puts "Copied #{multiline ? 'multilined' : ''}!"
  end

  Pry.config.commands.alias_command 'cp', 'pbcopy'
end

# ==============================
#   Rails
# ==============================

if defined?(Rails)
  begin
    require "rails/console/app"
    require "rails/console/helpers"
  rescue LoadError => e
    require "console_app"
    require "console_with_helpers"
  end
end

